/*
* Copyright (C) 2025 Hosein Hadipour and Mostafizar Rahman
* Email: hsn.hadipour@gmail.com
* Date: September 30, 2025
* 
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <https://www.gnu.org/licenses/>.
*/

#include "utils.c"

int ORTHROS( unsigned char *ptbr1, unsigned char *ciphertext, unsigned char expdKey1[][32],unsigned char expdKey2[][32], int offset, int roundNum);
int Process_Branch(unsigned char *state, unsigned char rk[][32], int BRANCH, int offset, int roundNum);
int BITPERM(unsigned char *state, int BRANCH);
int NIBBLEPERM(unsigned char *state, int BRANCH);
int KEYSCHEDULING(unsigned char *rk, int BRANCH);

int NIBBLEtoBIT(unsigned char *nibble, unsigned char *bit);
int BITtoNIBBLE(unsigned char *nibble, unsigned char *bit);

void DISPLAY(unsigned char *state, char *text);

const int modeLeftBr=0;
const int modeRightBr=1;
const int modePRF=2;

unsigned char RC_1[12][32] = {
    {0xa,0x0,0xa,0xc,0x9,0x3,0x2,0x9,0xa,0xc,0x4,0xb,0xc,0x9,0x9,0x1,0xc,0x2,0x3,0x1,0x3,0x2,0x1,0x9,0xc,0x1,0x9,0x3,0xc,0xa,0x8,0x1,},
    {0x4,0x4,0x2,0x0,0xc,0xb,0x8,0xb,0x4,0x9,0xc,0xc,0x9,0xb,0xa,0x8,0x8,0x2,0xc,0x1,0x0,0x4,0xb,0xa,0x4,0xa,0x2,0x2,0xc,0x9,0x1,0x8,},
    {0x3,0xc,0x0,0xb,0x2,0x0,0x3,0x1,0x4,0x3,0x1,0x0,0x4,0x4,0xc,0xc,0x3,0x1,0x4,0x0,0x1,0xa,0x4,0x1,0x2,0x9,0xa,0x1,0x0,0x8,0xb,0x8,},
    {0x3,0x3,0xc,0xc,0x1,0x0,0xa,0x4,0x0,0x4,0x3,0x2,0x8,0x9,0x9,0x4,0x1,0x1,0x8,0x3,0x3,0x2,0x3,0x8,0x4,0x9,0xc,0x2,0x2,0x3,0x0,0x4,},
    {0xa,0xa,0x8,0x2,0xc,0x1,0x1,0x1,0x8,0xb,0x9,0x2,0x9,0xa,0xc,0xa,0x0,0x4,0x0,0x9,0x4,0x2,0x4,0x0,0x8,0x8,0xb,0xa,0x2,0x8,0x1,0x4,},
    {0x2,0x0,0x8,0x1,0x3,0x8,0x0,0xc,0x9,0xc,0x2,0x9,0x0,0x8,0x8,0x2,0xa,0xa,0xc,0xb,0x2,0x2,0x3,0x1,0x1,0x4,0xa,0x4,0x4,0xa,0xa,0x4,},
    {0x9,0x8,0x1,0xc,0x0,0xc,0xb,0x2,0x2,0x1,0x4,0x4,0x0,0x8,0x4,0xb,0xa,0xb,0x3,0x2,0xc,0x9,0x9,0xa,0x2,0x3,0x0,0x9,0x4,0x2,0x3,0xa,},
    {0xb,0x2,0x4,0x1,0x1,0x9,0xb,0xc,0x3,0x3,0xc,0x1,0x8,0xb,0x2,0x9,0x3,0x8,0x9,0x0,0x0,0xc,0x8,0x4,0x8,0xa,0x2,0xb,0x2,0x4,0x2,0xb,},
    {0x3,0x4,0x9,0x1,0xa,0x3,0x0,0x1,0xa,0x4,0x3,0x0,0x8,0x2,0x2,0xa,0x1,0x9,0x3,0x3,0x2,0x4,0x1,0x0,0x9,0x9,0xc,0x9,0xb,0x0,0x3,0x9,},
    {0x3,0x0,0x1,0x2,0x4,0x8,0xa,0x0,0x9,0x3,0x9,0xb,0x9,0x2,0x2,0xc,0x3,0x8,0x0,0x3,0x3,0x0,0x3,0x1,0x8,0xa,0xa,0xc,0x4,0x0,0xb,0xa,},
    {0x4,0x4,0x0,0xa,0x9,0x0,0x4,0x9,0x0,0x4,0xb,0x1,0x4,0x1,0x4,0x9,0x2,0xa,0x0,0x4,0x8,0xb,0x8,0xa,0x9,0xb,0x2,0x1,0xb,0x3,0xc,0x4,},
    {0x9,0x2,0xc,0x8,0x1,0xb,0x0,0x0,0x0,0x8,0x9,0x9,0x8,0x2,0x9,0x8,0x2,0xa,0x4,0x4,0x1,0x0,0x2,0x3,0x3,0x2,0x9,0x0,0x9,0xc,0x2,0x0,},
};

unsigned char RC_2[12][32] = {
    {0xa,0x3,0x4,0xa,0x8,0xc,0xa,0x0,0xa,0x8,0x8,0xb,0x0,0x4,0xa,0x1,0x9,0x8,0x2,0xb,0x9,0x3,0x8,0x1,0xb,0x2,0xb,0xa,0xc,0xa,0xc,0x8,},
    {0xc,0xa,0x9,0x8,0x4,0x9,0x0,0xc,0x3,0x0,0x8,0xb,0x9,0xc,0x0,0xc,0x9,0x9,0x3,0x0,0x8,0xb,0xc,0x9,0x8,0x8,0x2,0x8,0x8,0xc,0x2,0xa,},
    {0x4,0x0,0x3,0xa,0x2,0x3,0x1,0x1,0xb,0xc,0xc,0xb,0x1,0x3,0xa,0x4,0xa,0xb,0x3,0x9,0xa,0x8,0xc,0x4,0x2,0xb,0xa,0x9,0x3,0x9,0x2,0x4,},
    {0x4,0x8,0x9,0x1,0x3,0xc,0x9,0xc,0x0,0xc,0x1,0x8,0x0,0x8,0xc,0xa,0x4,0x8,0x9,0x4,0xc,0x1,0x9,0xb,0x3,0x9,0x9,0xb,0x1,0x2,0x2,0x0,},
    {0x3,0x2,0xb,0x3,0x2,0x1,0x8,0x4,0x3,0x0,0x1,0x0,0x9,0xc,0xa,0x4,0xa,0x3,0x1,0xc,0xa,0x9,0x1,0x2,0x3,0x9,0xb,0x8,0xc,0x8,0x3,0x8,},
    {0x1,0x0,0xb,0xc,0xc,0x3,0x0,0x4,0xa,0x1,0xb,0x8,0x1,0x3,0xb,0x8,0x2,0x9,0xc,0x9,0x0,0xb,0x8,0xb,0xb,0x1,0x4,0x9,0x8,0xb,0xb,0x3,},
    {0xa,0x9,0x1,0xc,0x2,0x3,0x3,0xa,0x4,0x0,0xc,0x2,0x3,0x3,0xb,0x3,0x4,0xa,0x0,0x2,0x8,0x9,0x9,0x0,0x0,0x0,0x2,0xb,0x4,0x0,0x9,0x3,},
    {0x8,0xa,0x2,0x9,0x3,0x1,0xa,0xb,0x0,0x4,0x1,0x3,0xb,0xc,0x2,0xb,0xb,0x8,0x9,0xa,0x1,0x3,0xa,0xb,0xb,0xc,0x4,0xb,0x0,0x4,0x8,0xb,},
    {0x9,0xb,0x1,0xb,0x8,0xb,0xc,0x3,0x9,0x0,0xa,0x3,0x4,0x2,0x2,0x0,0x4,0x8,0x0,0x9,0x1,0x2,0x4,0xa,0x9,0xa,0x1,0x8,0x0,0xa,0x3,0x2,},
    {0xa,0x4,0xa,0xc,0x2,0x9,0xb,0x8,0x8,0x2,0x8,0x3,0xc,0x9,0x1,0x3,0xc,0xb,0x4,0x4,0x9,0x2,0xc,0x4,0x9,0x1,0xa,0xa,0x1,0x0,0x0,0xc,},
    {0xc,0xa,0xb,0x0,0x8,0x9,0x0,0x9,0x4,0x8,0x1,0x0,0xc,0xb,0x0,0x4,0x3,0x2,0x0,0x1,0xa,0x2,0x0,0xc,0x0,0xa,0xc,0xc,0x0,0x9,0xb,0x1,},
    {0x4,0xb,0xb,0xa,0x3,0xb,0x8,0x9,0x8,0x4,0xc,0xb,0x0,0x2,0x8,0xc,0x3,0x8,0x3,0x9,0x0,0x8,0x9,0xa,0x4,0xc,0xc,0xc,0xc,0xc,0xc,0x1,},
};

unsigned char permN1[32] = {10,27,5,1,30,23,16,13,21,31,6,14,0,25,11,18,15,28,19,24,7,8,22,3,4,29,9,2,26,20,12,17};
unsigned char permN2[32] = {26,13,7,11,29,0,17,21,23,5,18,25,12,10,28,2,14,19,24,22,1,8,4,31,15,6,27,9,16,30,20,3};

unsigned int permB1[128] = {6,46,62,126,70,52,28,14,36,125,72,83,106,95,4,35,25,41,10,76,87,74,120,42,88,21,11,67,64,38,112,50,85,109,24,65,99,0,49,37,8,66,114,47,127,100,56,40,13,117,78,86,92,58,124,101,55,89,97,9,18,116,59,15,20,45,75,2,77,27,1,60,115,107,26,69,119,3,84,51,123,110,31,82,113,53,81,102,63,118,93,12,30,94,108,32,5,111,29,43,91,19,79,33,73,44,98,48,22,61,68,105,34,71,54,104,17,57,80,103,96,121,23,39,122,90,7,16};
unsigned int permB2[128] = {20,122,74,62,119,35,15,66,9,85,32,117,21,83,127,106,11,98,115,59,71,90,56,26,2,44,103,121,114,107,68,16,84,1,102,33,80,52,76,36,27,94,37,55,82,12,112,64,105,14,91,17,108,124,6,93,29,86,123,79,72,53,19,99,50,18,81,73,67,88,4,61,111,49,24,45,57,78,100,22,110,47,116,54,60,70,97,39,3,41,48,96,23,42,113,87,126,13,31,40,51,25,65,125,8,101,118,28,38,89,5,104,109,120,69,43,7,77,58,34,10,63,30,95,75,46,0,92};

unsigned int permK1[128] = {0,53,87,73,22,95,99,48,61,36,108,1,24,67,119,93,54,103,69,112,16,111,94,122,31,66,33,83,47,3,65,62,123,9,101,19,5,58,89,37,38,51,28,106,82,76,121,4,70,7,42,92,104,80,45,75,114,17,2,97,46,107,63,18,109,15,127,43,13,59,29,125,77,11,50,30,12,90,118,64,20,35,57,10,124,56,68,91,116,21,84,98,52,81,126,34,105,27,120,74,6,85,40,72,113,41,23,49,79,55,102,8,117,39,88,26,25,110,14,32,115,100,86,71,78,44,96,60};
unsigned int permK2[128] = {76,30,53,35,31,46,2,79,11,125,110,87,39,91,14,101,97,118,36,48,29,80,57,115,49,18,74,85,61,82,105,126,70,12,47,111,51,17,66,1,60,96,116,71,81,114,104,15,42,124,100,4,113,44,75,89,23,0,84,107,32,26,88,8,69,121,38,94,37,86,54,21,62,123,41,10,16,95,117,65,45,50,72,20,109,58,7,67,108,28,3,55,92,103,24,5,77,9,27,102,122,6,106,22,99,34,90,56,43,83,120,64,78,59,119,93,40,98,52,68,112,33,63,25,19,73,127,13};

unsigned int invPermK1[128]={0,11,58,29,47,36,100,49,111,33,83,73,76,68,118,65,20,57,63,35,80,89,4,106,12,116,115,97,42,70,75,24,119,26,95,81,9,39,40,113,102,105,50,67,125,54,60,28,7,107,74,41,92,1,16,109,85,82,37,69,127,8,31,62,79,30,25,13,86,18,48,123,103,3,99,55,45,72,124,108,53,93,44,27,90,101,122,2,114,38,77,87,51,15,22,5,126,59,91,6,121,34,110,17,52,96,43,61,10,64,117,21,19,104,56,120,88,112,78,14,98,46,23,32,84,71,94,66};
unsigned int invPermK2[128]={57,39,6,90,51,95,101,86,63,97,75,8,33,127,14,47,76,37,25,124,83,71,103,56,94,123,61,98,89,20,1,4,60,121,105,3,18,68,66,12,116,74,48,108,53,80,5,34,19,24,81,36,118,2,70,91,107,22,85,113,40,28,72,122,111,79,38,87,119,64,32,43,82,125,26,54,0,96,112,7,21,44,29,109,58,27,69,11,62,55,106,13,92,115,67,77,41,16,117,104,50,15,99,93,46,30,102,59,88,84,10,35,120,52,45,23,42,78,17,114,110,65,100,73,49,9,31,126};

unsigned char SBOX[16] = {0x1,0x0,0x2,0x4,0x3,0x8,0x6,0xd,0x9,0xa,0xb,0xe,0xf,0xc,0x7,0x5};



int ORTHROS( unsigned char *ptbr1, unsigned char *ciphertext, unsigned char expdKey1[][32],unsigned char expdKey2[][32], int offset, int roundNum){
    // unsigned char plaintext[32],key[32];
    // hex_string_to_bytes(pt,plaintext,sizeof(plaintext));
    // hex_string_to_bytes(K,key,sizeof(key));


    unsigned char X1[32] = {0x0};
    unsigned char X2[32] = {0x0};


    for(int i = 0; i < 32; i++){
        X1[i] = ptbr1[i];
        X2[i] = ptbr1[i];
    }
    // printState(X1,"\np:");
    Process_Branch(X1, expdKey1, 1, offset, roundNum);
    Process_Branch(X2, expdKey2, 2, offset, roundNum);
    for(int i = 0; i < 32; i++){
        ciphertext[i] = X1[i] ^ X2[i];
    }
    return 0;
  
}

int Process_Branch(unsigned char *state, unsigned char rk[][32], int BRANCH, int offset, int roundNum){

    for(int i = 0; i < 32; i++){
        state[i] ^= rk[offset][i];
    }

    //round function in 1st to 11th rounds   
    // roundNum-1 should be changed to roundNum if a complete last round is required; remove the last round codes in the end of this function  
    for(int r = offset; r < (offset+roundNum); r++){

        //sbox
        for(int i = 0; i < 32; i++){
            state[i] = SBOX[state[i]];
        }

        //test
        //printf("%d  ", BRANCH);
        //DISPLAY(state);
        //permutation
        if(r < 4){
            BITPERM(state, BRANCH);
        }
        else{
            NIBBLEPERM(state, BRANCH);
        }

        //mixcolumn
        unsigned char buf[32] = {0x0};
        for(int i = 0; i < 32; i++){
            buf[i] = state[i];
        }
        for(int i = 0; i < 8; i++){
            state[(i*4)+0] = buf[(i*4)+1] ^ buf[(i*4)+2] ^ buf[(i*4)+3];
            state[(i*4)+1] = buf[(i*4)+0] ^ buf[(i*4)+2] ^ buf[(i*4)+3];
            state[(i*4)+2] = buf[(i*4)+0] ^ buf[(i*4)+1] ^ buf[(i*4)+3];
            state[(i*4)+3] = buf[(i*4)+0] ^ buf[(i*4)+1] ^ buf[(i*4)+2];
        }


        if(BRANCH == 1){
            for(int i = 0; i < 32; i++){
                state[i] ^= rk[r+1][i] ^ RC_1[r][i];
            }
        }
        else{
            for(int i = 0; i < 32; i++){
                state[i] ^= rk[r+1][i] ^ RC_2[r][i];
            }
        }
    }

    return 0;
}

int BITPERM(unsigned char *state, int BRANCH){

    //bit permutation
    unsigned char bit[128] = {0x0};
    unsigned char bit_buf[128] = {0x0};

    NIBBLEtoBIT(state, bit);

    if(BRANCH == 1){
        for(int i = 0; i < 128; i++){
            bit_buf[permB1[i]] = bit[i];
        }
    }
    else{
        for(int i = 0; i < 128; i++){
            bit_buf[permB2[i]] = bit[i];
        }
    }

    BITtoNIBBLE(state, bit_buf);

    return 0;
}

int NIBBLEPERM(unsigned char *state, int BRANCH){

    unsigned char nibble_buf[32] = {0x0};
    for(int i = 0; i < 32; i++){
        nibble_buf[i] = state[i];
    }

    if(BRANCH == 1){
        for(int i = 0; i < 32; i++){
            state[permN1[i]] = nibble_buf[i];
        }
    }
    else{
        for(int i = 0; i < 32; i++){
            state[permN2[i]] = nibble_buf[i];
        }
    }

    return 0;
}

int KEYSCHEDULING(unsigned char *rk, int BRANCH){

    unsigned char bit[128] = {0x0};
    unsigned char bit_buf[128] = {0x0};

    NIBBLEtoBIT(rk, bit);

    //permutation
    if(BRANCH == 1){
        for(int i = 0; i < 128; i++){
            bit_buf[permK1[i]] = bit[i];
        }
    }
    else{
        for(int i = 0; i < 128; i++){
            bit_buf[permK2[i]] = bit[i];
        }
    }

    BITtoNIBBLE(rk, bit_buf);

    return 0;
}

int INVERSEKEYSCHEDULING(unsigned char *rk, int BRANCH){

    unsigned char bit[128] = {0x0};
    unsigned char bit_buf[128] = {0x0};

    NIBBLEtoBIT(rk, bit);

    //permutation
    if(BRANCH == 1){
        for(int i = 0; i < 128; i++){
            bit_buf[invPermK1[i]] = bit[i];
        }
    }
    else{
        for(int i = 0; i < 128; i++){
            bit_buf[invPermK2[i]] = bit[i];
        }
    }

    BITtoNIBBLE(rk, bit_buf);

    return 0;
}


int NIBBLEtoBIT(unsigned char *nibble, unsigned char *bit){

    //initialization
    for(int i = 0; i < 128; i++){
        bit[i] = 0;
    }

    for(int i = 0; i < 32; i++){
        for(int j = 0; j < 4; j++){
            bit[(4*i)+j] = (nibble[i] >> (3-j)) & 0x1;
        }
    }

    return 0;
}

int BITtoNIBBLE(unsigned char *nibble, unsigned char *bit){

    //initialization
    for(int i = 0; i < 32; i++){
        nibble[i] = 0;
    }

    for(int i = 0; i < 32; i++){
        nibble[i] = (bit[(4*i)+0] << 3) ^ (bit[(4*i)+1] << 2) ^ (bit[(4*i)+2] << 1) ^ (bit[(4*i)+3] << 0);
    }

    return 0;
}

void DISPLAY(unsigned char *state, char *text){

    printf("%s: ", text);
    for(int i = 0; i < 32; i++){
        printf("%x", state[i]);
    }
    printf("\n");
}
